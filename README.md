# SwiftPay - 결제시스템
> refactor 브랜치에서 리팩토링 진행중..
---

```text
서버 구성 - On Premise

CPU - N200 / RAM 16GB
Ubuntu 24.04.03 LTS

Infra
- Jenkins
- K3S
- Kaniko
```


## 페이먼츠 핵심 : 에스크로(Escrow) 시스템
### 개념
중개자(플랫폼)가 구매자와 판매자 사이에서 **결제금을 일시적으로 보관**하다가,
거래 완료 조건이 충족되면 판매자에게 정산하는 시스템.
### 플로우
```
1. 구매자 결제 → 2. 에스크로 예치 → 3. 상품/서비스 제공 → 4. 구매 확정 → 5. 판매자 정산
```

### 핵심 기능
- **예치(Hold)**: 결제 승인 후 자금 보관
- **정산(Settlement)**: 구매 확정 후 판매자에게 송금
- **환불(Refund)**: 취소/반품 시 구매자 환급
- **분쟁 처리**: 문제 발생 시 중재 및 자금 분배

### 안정성 요구사항
✅ 이중 결제 방지 (멱등성 보장)  
✅ 금액 불일치 방지 (트랜잭션 원자성)  
✅ 정산 누락 방지 (이벤트 소싱)

---

### 학습 목표
✅ Kotlin + Coroutine  
✅ Redis 분산 시스템 구축  
✅ Kafka 이벤트 드리븐 아키텍처  
✅ 대용량 트래픽 처리

### 성능목표
✅ 평균 응답시간 300ms 이하  
✅ P99 응답시간 500ms 이하  
✅ 동시 사용자 처리 1,300명 이상

---

## 개발 진척도

### Phase 1 - 기본 인프라
- [x] 상점 등록 및 API Key 발급
- [x] 결제 요청 API
> 이제 결제 요청 이후 검증해야 할 것.
> 1. orderId 와 merchantId, apiKey 검증하여 유효한 주문요청인지 확인
> 2. payment 의 amount가 orderId의 amount와 같은지 검증
> 3. 결제 여부에 따라 orderId 사용 여-부 알려줘야함.
     >    4. 짧게 검증하는거니.. DB에 저장 안하고 Redis를 통해서 검증해도 될거같고.. 고민포인트


### Phase 2 - 에스크로 (진행중)
- [x] 결제 예치 (Hold)
- [ ] 구매 확정 처리
- [ ] 판매자 정산 배치
- [ ] 환불 처리

### Phase 3 - 안정성 (예정)
- [ ] 멱등성 키 기반 중복 방지
- [ ] 분산 트랜잭션 처리
- [ ] 정산 실패 재시도 로직
- [ ] 이벤트 소싱 도입
